/*********************************************************************/
/* This C code implements a ghetto version of minesweeper						 */
/* with logic and has functions to manipulate peripherals on 				 */
/* the Freedom KL46Z board. 																				 */
/* Name:  Ayush Rout, Jack Xu                                        */
/* Date:  12/04/2018			                                           */
/* Class:  CMPE 250                                                  */
/* Section:  01L01 (11AM)				                                     */
/*-------------------------------------------------------------------*/
/* Template:  R. W. Melton                                           */
/*            March 30, 2018                                         */
/*********************************************************************/

/*Library Imports*/
#include "MKL46Z4.h"
#include "Minesweeper.h"
#include "RTE_Components.h"  
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include<stdbool.h>

/*constants*/
#define MAXSTRING (79)
#define POS_RED	(29)
#define POS_GREEN (5)
#define LED_RED_MASK (1 << POS_RED)
#define LED_GREEN_MASK (1<< POS_GREEN)
//Define Number of Front and Back plane pins
#define LCD_NUM_FRONTPLANE_PINS 8
#define LCD_NUM_BACKPLANE_PINS 4
//Create macros for segments
#define LCD_SEG_D 0x11
#define LCD_SEG_E 0x22
#define LCD_SEG_G 0x44
#define LCD_SEG_F 0x88
#define LCD_SEG_DECIMAL 0x11
#define LCD_SEG_C 0x22
#define LCD_SEG_B 0x44
#define LCD_SEG_A 0x88
#define LCD_CLEAR 0x00
//Create Macros for each pin
#define LCD_FRONTPLANE0 37u
#define LCD_FRONTPLANE1 17u
#define LCD_FRONTPLANE2 7u
#define LCD_FRONTPLANE3 8u
#define LCD_FRONTPLANE4 53u
#define LCD_FRONTPLANE5 38u
#define LCD_FRONTPLANE6 10u
#define LCD_FRONTPLANE7 11u
#define LCD_BACKPLANE0 40u
#define LCD_BACKPLANE1 52u
#define LCD_BACKPLANE2 19u
#define LCD_BACKPLANE3 18u
//Macros for turning decimal points and colon on and off
#define SegLCD_DP1_On() LCD->WF8B[LCD_FRONTPLANE1]  |= LCD_SEG_DECIMAL;
#define SegLCD_DP1_Off() LCD->WF8B[LCD_FRONTPLANE1] &= ~LCD_SEG_DECIMAL;
#define SegLCD_DP2_On() LCD->WF8B[LCD_FRONTPLANE3]  |= LCD_SEG_DECIMAL;
#define SegLCD_DP2_Off() LCD->WF8B[LCD_FRONTPLANE3] &= ~LCD_SEG_DECIMAL;
#define SegLCD_DP3_On() LCD->WF8B[LCD_FRONTPLANE5]  |= LCD_SEG_DECIMAL;
#define SegLCD_DP3_Off() LCD->WF8B[LCD_FRONTPLANE5] &= ~LCD_SEG_DECIMAL;
#define SegLCD_Col_On() LCD->WF8B[LCD_FRONTPLANE7]  |= LCD_SEG_DECIMAL;
#define SegLCD_Col_Off() LCD->WF8B[LCD_FRONTPLANE7] &= ~LCD_SEG_DECIMAL;

/*Function Prototypes*/
void SegLCD_DisplayDecimal(uint16_t Value);
void Set0s(int x1,int y1);
/*Global Variables*/
unsigned short MyRandomSeed =0;
int x, y;									//user input for rows and columns
int xval =0;							//rows in integer format
int yval = 0;							//cols in interger format
int M, N;									//rows and columns for initialization
float diff;								//difficulty 
int tot_mines = 0;				//total number of mines
int mines = 0;						//mines represented as integers
int board[30][30];				//game board
int blank_board[30][30];	//game board (mines invisible)
int final_board[30][30];	//final game board for output
int score;								//player score
int MAX_SCORE;						//max possible score for each level of difficulty 
bool GameOver;						//T-game is over, F-game is not over
int PlayAgain;						//0-user doesnt want to play again, 1-user wants to play again
int match;								//number of valid selections
int HowMuchTime;					//total time for each difficulty 
int ResetDifficulty = 0;	//
int FirstStep =	0;				//if its user's first step
const static uint8_t LCD_Frontplane_Pin[LCD_NUM_FRONTPLANE_PINS] = {LCD_FRONTPLANE0, LCD_FRONTPLANE1, LCD_FRONTPLANE2, LCD_FRONTPLANE3, LCD_FRONTPLANE4, LCD_FRONTPLANE5, LCD_FRONTPLANE6, LCD_FRONTPLANE7};
const static uint8_t LCD_Backplane_Pin[LCD_NUM_BACKPLANE_PINS] = {LCD_BACKPLANE0, LCD_BACKPLANE1, LCD_BACKPLANE2, LCD_BACKPLANE3};
int TouchActivated = 0;		//whether TSI registers touch input

/*Peripheral manipultations*/

/****************************LED******************************/
void Red_LED_ON(void) {
	//PSOR is turn off
	FPTE -> PCOR = LED_RED_MASK; 
	//PCOR is to turn on
	FPTD -> PSOR = LED_GREEN_MASK;
}

void Green_LED_ON(void){
	//PSOR is turn off
	FPTE -> PSOR = LED_RED_MASK; 
	//PCOR is to turn on
	FPTD -> PCOR = LED_GREEN_MASK;
}

void BlinkLED1(void){//This method turns the LED off, then back on using two separate commands.
    uint32_t i = 0; //Create a loop variable
     
    PTD->PSOR = (1u<<5); //Set PTD5 = 1, turns LED OFF (Cathode connected to PTD5)
    for(i; i < 3000000; i++){}; //Burn some time
    PTD->PCOR = (1u<<5); //Clear PTD5 = 0, turns LED ON
    for(i; i < 3000000; i++){}; //Burn some time
}

void BlinkLED2(void){//This method turns the LED off, then back on using PDOR
    //Note the use of |= and &=.  This allows you to change the 5th bit of PDOR without disturbing the other bits.  The other methods do not require this as setting PSOR/PCOR/PTOR = 0 does not change the output.
    uint32_t i = 0; //Create a loop variable
     
    PTD->PDOR |= (1u<<5); //Change PTD5 to 1, turns LED OFF (Cathode connected to PTD5)
    for(i; i < 600000; i++){}; //Burn some time
    PTD->PDOR &= ~((uint32_t)(1u<<5)); //Change PTD5 to 0, turns LED ON.  This line is a bit weird.  First it takes 1u<<5 and typecasts ( http://en.wikipedia.org/wiki/Type_conversion ) it to a 32 bit value.  It then takes the inverse of it, so all bits are 1 except bit 5.  It then logical ands it with the current PDOR, which will retain all values except bit 5 which will be changed to 0.
    for(i; i < 600000; i++){}; //Burn some time
}
/********************************LED******************************/

//-------------------------------------------------------------------------------------------------------------------------------//

/********************************LCD******************************/
void SegLCD_Init(void){ //Initializes all components of SLCD on the FRDM-KL46Z
  
 SIM->SCGC5 |= SIM_SCGC5_PORTB_MASK | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK | SIM_SCGC5_PORTE_MASK | SIM_SCGC5_SLCD_MASK; //Enable Clock to ports B, C, D and E, and SegLCD Peripheral
 LCD->GCR |= LCD_GCR_PADSAFE_MASK; //Set PADSAFE to disable LCD while configuring
 LCD->GCR &= ~LCD_GCR_LCDEN_MASK;  //Clear LCDEN (LCD Enable) while configuring
  
 //Configure pins *From Reference manual, set pins to MUX 0 for normal LCD display operation, only use MUX 7 if using LCD fault detection
 PORTB->PCR[7]  = PORT_PCR_MUX(0u);     //Set PTB7 to LCD_P7
 PORTB->PCR[8]  = PORT_PCR_MUX(0u);     //Set PTB8 to LCD_P8
 PORTB->PCR[10] = PORT_PCR_MUX(0u);     //Set PTB10 to LCD_P10
 PORTB->PCR[11] = PORT_PCR_MUX(0u);     //Set PTB11 to LCD_P11
 PORTB->PCR[21] = PORT_PCR_MUX(0u);     //Set PTB21 to LCD_P17
 PORTB->PCR[22] = PORT_PCR_MUX(0u);     //Set PTB22 to LCD_P18
 PORTB->PCR[23] = PORT_PCR_MUX(0u);     //Set PTB23 to LCD_P19
 PORTC->PCR[17] = PORT_PCR_MUX(0u);     //Set PTC17 to LCD_P37
 PORTC->PCR[18] = PORT_PCR_MUX(0u);     //Set PTC18 to LCD_P38
 PORTD->PCR[0]  = PORT_PCR_MUX(0u);     //Set PTD0 to LCD_P40
 PORTE->PCR[4]  = PORT_PCR_MUX(0u);     //Set PTE4 to LCD_P52
 PORTE->PCR[5]  = PORT_PCR_MUX(0u);     //Set PTE5 to LCD_P53
  
 //Configure LCD Registers
 //Configure LCD_GCR - General Control Register, controls most options in LCD Peripheral
 LCD->GCR =//LCD_GCR_RVEN_MASK |       //Clear LCD_GCR_RVEN, disable voltage regulator.
       LCD_GCR_RVTRIM(0x00) |      //Set RVTRIM to 0, irrelevant as voltage regulator is disabled, but setting it to a known state.
       LCD_GCR_CPSEL_MASK |      //Set LCD_GCR_CPSEL to use capacitor charge pump.
       LCD_GCR_LADJ(0x03) |      //Set LCD_GCR_LADJ to 11, slow clock rate = lower power, but higher load capacitance on the LCD requires higher clock speed.
      //LCD_GCR_VSUPPLY |        //Clear LCD_GCR_VSUPPLY, drive VLL3 externally.
       LCD_GCR_PADSAFE_MASK |     //Set LCD_GCR_PADSAFE, leave enabled during configuration process.
      //LCD_GCR_FDCIEN_MASK |      //Clear LCD_GCR_FDCIEN, No interrupt from fault dection.
       LCD_GCR_ALTDIV(0x00) |     //Set LCD_GCR_ALTDIV to 11, divide alternate clock by 512.  This is assuming an 8MHz External Crystal is used.
      //LCD_GCR_ALTSOURCE_MASK |    //Set LCD_GCR_ALTSOURCE, Part of setting clock source to OSCERCLK, or external oscillator.
       LCD_GCR_FFR_MASK |       //Set LCD_GCR_FFR, allow an LCD Frame Frequency of 46.6Hz to 146.2Hz.  Disable to change range to 23.3Hz to 73.1Hz.
      //LCD_GCR_LCDDOZE_MASK |     //Clear LCD_GCR_LCDDOZE, allows LCD peripheral to run even in doze mode.  Set to disable LCD in doze mode.
      //LCD_GCR_LCDSTP_MASK |      //Clear LCD_GCR_LCDSTP, allows LCD peripheral to run even in stop mode.  Set to disable LCD in stop mode.
      //LCD_GCR_LCDEN_MASK |      //Clear LCD_GCR_LCDEN, Disables all front and backplane pins.  Leave disabled during configuration process.
       LCD_GCR_SOURCE_MASK |      //Set LCD_GCR_SOURCE, Part of setting clock source to OSCERCLK, or external oscillator.
       LCD_GCR_LCLK(0x04) |       //Set LCD_GCR_LCLK to 111, LCD Clock prescaler where LCD controller frame frequency = LCD clock/((DUTY  |  1) x 8 x (4 | LCLK[2:0]) x Y), where Y = 2, 2, 3, 3, 4, 5, 8, 16 chosen by module duty cycle config
       LCD_GCR_DUTY(0x03);        //Set LCD_GCR_DUTY to 011, Have 4 backplane pins, so need a 1/4 duty cycle.
  
 //Configure LCD_SEG_AR  - Auxiliary Register, controls blinking of LCD
 LCD->AR = //LCD_AR_BLINK_MASK |       //Clear LCD_SEG_AR_BLINK, Disable SLCD blinking.  Enable to make LCD Blink.
      //LCD_AR_ALT_MASK |        //Clear LCD_SEG_AR_ALT, if enabled LCD back plane sequencer changes to an alternate display.  Only functional if DUTY[2:0] is less than 100(binary).  This allows a blink screen that is not blank.
      //LCD_AR_BLANK_MASK |       //Clear LCD_SEG_AR_BLANK, asserting bit clears all segments in LCD.
      //LCD_AR_BMODE_MASK |       //Clear LCD_SEG_AR_BMODE, if enabled displays alternate display during blink period instead of blank.
      LCD_AR_BRATE(0x00);        //Set LCD_SEG_AR_BRATE to 000.  Frequency of blink is determined by LCD clock/(2^(12 + BRATE))
       
 //Configure LCD_SEG_FDCR - Fault Detect Control Register, controls use of Fault Detect features of SLCD.
 LCD->FDCR = 0x00000000;           //Clear all bits in FDCR.  As this will not be covering use of fault detect, this register is cleared.
  
 //Configure LCD_PENn - Pin Enable Register, controls which of the possible LCD pins are used
 //LCD->PEN[0] contains bits 0-31, while LCD->PEN[1] contains bits 32-63.  For pins >= 32, set in LCD->PEN[1] as LCD_PEN_PEN(Pin#-32)
 LCD->PEN[0] =  LCD_PEN_PEN(1u<<7u) |    //LCD_P7
         LCD_PEN_PEN(1u<<8u) |    //LCD_P8
         LCD_PEN_PEN(1u<<10u)|    //LCD_P10
         LCD_PEN_PEN(1u<<11u)|    //LCD_P11
         LCD_PEN_PEN(1u<<17u)|    //LCD_P17
         LCD_PEN_PEN(1u<<18u)|    //LCD_P18
         LCD_PEN_PEN(1u<<19u);    //LCD_P19
 LCD->PEN[1] =  LCD_PEN_PEN(1u<<5u) |    //LCD_P37
         LCD_PEN_PEN(1u<<6u) |    //LCD_P38
         LCD_PEN_PEN(1u<<8u) |    //LCD_P40
         LCD_PEN_PEN(1u<<20u)|    //LCD_P52
         LCD_PEN_PEN(1u<<21u);    //LCD_P53
  
 //Configure LCD_SEG_BPENn - Back Plane Enable Register, controls which pins in LCD->PEN are Back Plane (commons)
 //LCD->BPEN[0] contains bits 0-31, while LCD->BPEN[1] contains bits 32-63.  For pins >= 32, set in LCD->BPEN[1] as LCD_BPEN_BPEN(Pin#-32)
 LCD->BPEN[0] = LCD_BPEN_BPEN(1u<<18u)|   //LCD_P18  COM3
         LCD_BPEN_BPEN(1u<<19u);   //LCD_P19, COM2
 LCD->BPEN[1] = LCD_BPEN_BPEN(1u<<8u) |   //LCD_P40, COM0
         LCD_BPEN_BPEN(1u<<20u);   //LCD_P52, COM1
  
 //Configure LCD_WFyTOx - Configures 4 Waveform signals, LCD_WF[z] is defined such that x = (z*4) and y = 3 | (z*4)
 //Where x is the n index value of WFn on the least significant byte (bits 7-0) and y is the n index value of WFn on the most significant byte (bits 31-24)
 //Note that "Disabled" is used for pins that are not set as LCD pins, where "Off" is used for pins that are set as LCD, but are just inactive.
 LCD->WF[0]  = LCD_WF_WF0(0x00) |      //WF Pin 0 Disabled
         LCD_WF_WF1(0x00) |      //WF Pin 1 Disabled
         LCD_WF_WF2(0x00) |      //WF Pin 2 Disabled
         LCD_WF_WF3(0x00) ;      //WF Pin 3 Disabled
 LCD->WF[1]  = LCD_WF_WF4(0x00) |      //WF Pin 4 Disabled
         LCD_WF_WF5(0x00) |      //WF Pin 5 Disabled
         LCD_WF_WF6(0x00) |      //WF Pin 6 Disabled
         LCD_WF_WF7(0x00) ;      //WF Pin 7 Off
 LCD->WF[2]  = LCD_WF_WF8(0x00) |      //WF Pin 8 Off
         LCD_WF_WF9(0x00) |      //WF Pin 9 Disabled
         LCD_WF_WF10(0x00)|      //WF Pin 10 Off
         LCD_WF_WF11(0x00);      //WF Pin 11 Off
 LCD->WF[3]  = LCD_WF_WF12(0x00)|      //WF Pin 12 Disabled
         LCD_WF_WF13(0x00)|      //WF Pin 13 Disabled
         LCD_WF_WF14(0x00)|      //WF Pin 14 Disabled
         LCD_WF_WF15(0x00);      //WF Pin 15 Disabled
 LCD->WF[4]  = LCD_WF_WF16(0x00)|      //WF Pin 16 Disabled
         LCD_WF_WF17(0x00)|      //WF Pin 17 Off
         LCD_WF_WF18(0x88)|      //WF Pin 18 (COM3) is enabled on Phases D and H
         LCD_WF_WF19(0x44);      //WF Pin 19 (COM2) is enabled on Phases C and G
 LCD->WF[5]  = LCD_WF_WF20(0x00)|      //WF Pin 20 Disabled
         LCD_WF_WF21(0x00)|      //WF Pin 21 Disabled
         LCD_WF_WF22(0x00)|      //WF Pin 22 Disabled
         LCD_WF_WF23(0x00);      //WF Pin 23 Disabled
 LCD->WF[6]  = LCD_WF_WF24(0x00)|      //WF Pin 24 Disabled
         LCD_WF_WF25(0x00)|      //WF Pin 25 Disabled
         LCD_WF_WF26(0x00)|      //WF Pin 26 Disabled
         LCD_WF_WF27(0x00);      //WF Pin 27 Disabled
 LCD->WF[7]  = LCD_WF_WF28(0x00)|      //WF Pin 28 Disabled
         LCD_WF_WF29(0x00)|      //WF Pin 29 Disabled
         LCD_WF_WF30(0x00)|      //WF Pin 30 Disabled
         LCD_WF_WF31(0x00);      //WF Pin 31 Disabled
 LCD->WF[8]  = LCD_WF_WF32(0x00)|      //WF Pin 32 Disabled
         LCD_WF_WF33(0x00)|      //WF Pin 33 Disabled
         LCD_WF_WF34(0x00)|      //WF Pin 34 Disabled
         LCD_WF_WF35(0x00);      //WF Pin 35 Disabled
 LCD->WF[9]  = LCD_WF_WF36(0x00)|      //WF Pin 36 Disabled
         LCD_WF_WF37(0x00)|      //WF Pin 37 Off
         LCD_WF_WF38(0x00)|      //WF Pin 38 Off
         LCD_WF_WF39(0x00);      //WF Pin 39 Disabled
 LCD->WF[10] = LCD_WF_WF40(0x11)|      //WF Pin 40 (COM0) is enabled on Phases A and E
         LCD_WF_WF41(0x00)|      //WF Pin 41 Disabled
         LCD_WF_WF42(0x00)|      //WF Pin 42 Disabled
         LCD_WF_WF43(0x00);      //WF Pin 43 Disabled
 LCD->WF[11] = LCD_WF_WF44(0x00)|      //WF Pin 44 Disabled
         LCD_WF_WF45(0x00)|      //WF Pin 45 Disabled
         LCD_WF_WF46(0x00)|      //WF Pin 46 Disabled
         LCD_WF_WF47(0x00);      //WF Pin 47 Disabled
 LCD->WF[12] = LCD_WF_WF48(0x00)|      //WF Pin 48 Disabled
         LCD_WF_WF49(0x00)|      //WF Pin 49 Disabled
         LCD_WF_WF50(0x00)|      //WF Pin 50 Disabled
         LCD_WF_WF51(0x00);      //WF Pin 51 Disabled
 LCD->WF[13] = LCD_WF_WF52(0x22)|      //WF Pin 52 (COM1) is enabled on Phases B and F
         LCD_WF_WF53(0x00)|      //WF Pin 53 Off
         LCD_WF_WF54(0x00)|      //WF Pin 54 Disabled
         LCD_WF_WF55(0x00);      //WF Pin 55 Disabled
 LCD->WF[14] = LCD_WF_WF56(0x00)|      //WF Pin 56 Disabled
         LCD_WF_WF57(0x00)|      //WF Pin 57 Disabled
         LCD_WF_WF58(0x00)|      //WF Pin 58 Disabled
         LCD_WF_WF59(0x00);      //WF Pin 59 Disabled
 LCD->WF[15] = LCD_WF_WF60(0x00)|      //WF Pin 60 Disabled
         LCD_WF_WF61(0x00)|      //WF Pin 61 Disabled
         LCD_WF_WF62(0x00)|      //WF Pin 62 Disabled
         LCD_WF_WF63(0x00);      //WF Pin 63 Disabled
         
 //Disable GCR_PADSAFE and Enable GCR_LCDEN
 LCD->GCR &= ~LCD_GCR_PADSAFE_MASK;      //Clear PADSAFE to unlock LCD pins
 LCD->GCR |= LCD_GCR_LCDEN_MASK;       //Set LCDEN to enable operation of LCD
}//End SegLCD_Init 

void SegLCD_Set(uint8_t Value,uint8_t Digit){//Sets a value from 0-F to a specified Digit, with 1 being the leftmost, 4 being the rightmost. Will not display error is Value is outside of 0-F, but display will not update
 if(Value==0x00) {LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_SEG_D | LCD_SEG_E |LCD_SEG_F); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = (LCD_SEG_A | LCD_SEG_B | LCD_SEG_C);}
 else if(Value==0x01){LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_CLEAR); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = (LCD_SEG_B | LCD_SEG_C);}
 else if(Value==0x02){LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_SEG_D | LCD_SEG_E | LCD_SEG_G); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = (LCD_SEG_A | LCD_SEG_B);}
 else if(Value==0x03){LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_SEG_D | LCD_SEG_G); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = (LCD_SEG_A | LCD_SEG_B | LCD_SEG_C);}
 else if(Value==0x04){LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_SEG_F | LCD_SEG_G); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = (LCD_SEG_B | LCD_SEG_C);}
 else if(Value==0x05){LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_SEG_D | LCD_SEG_F | LCD_SEG_G); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = (LCD_SEG_A | LCD_SEG_C);}
 else if(Value==0x06){LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_SEG_D | LCD_SEG_E | LCD_SEG_F | LCD_SEG_G); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = (LCD_SEG_A | LCD_SEG_C);}
 else if(Value==0x07){LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_CLEAR); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = (LCD_SEG_A | LCD_SEG_B | LCD_SEG_C);}
 else if(Value==0x08){LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_SEG_D | LCD_SEG_E | LCD_SEG_F | LCD_SEG_G); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = (LCD_SEG_A | LCD_SEG_B | LCD_SEG_C);}
 else if(Value==0x09){LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_SEG_F | LCD_SEG_G); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = (LCD_SEG_A | LCD_SEG_B | LCD_SEG_C);}
 else if(Value==0x0A){LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_SEG_E | LCD_SEG_F | LCD_SEG_G); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = (LCD_SEG_A | LCD_SEG_B | LCD_SEG_C);}
 else if(Value==0x0B){LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_SEG_D | LCD_SEG_E | LCD_SEG_F | LCD_SEG_G); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = LCD_SEG_C;}
 else if(Value==0x0C){LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_SEG_D | LCD_SEG_E | LCD_SEG_F); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = LCD_SEG_A;}
 else if(Value==0x0D){LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_SEG_D | LCD_SEG_E | LCD_SEG_G); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = LCD_SEG_B | LCD_SEG_C;}
 else if(Value==0x0E){LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_SEG_D | LCD_SEG_E | LCD_SEG_F | LCD_SEG_G); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = LCD_SEG_A;}
 else if(Value==0x0F){LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-2)]] = (LCD_SEG_E | LCD_SEG_F | LCD_SEG_G); LCD->WF8B[LCD_Frontplane_Pin[((2*Digit)-1)]] = LCD_SEG_A;}
}//End SegLCD_Set

void SegLCD_DisplayDecimal(uint16_t Value){//Displays a 4 Digit number in decimal
  SegLCD_Set(Value/1000,1);
  SegLCD_Set((Value - (Value/1000)*1000)/100,2);
  SegLCD_Set((Value - (Value/100)*100)/10,3);
  SegLCD_Set(Value - (Value/10)*10,4);
}//End SegLCD_Display4Digit

void SegLCD_DisplayHex(uint16_t Value){ //Displays a 16 bit number in Hex Format
 SegLCD_Set((Value & 0xF000)>>12, 1);
 SegLCD_Set((Value & 0x0F00)>>8 , 2);
 SegLCD_Set((Value & 0x00F0)>>4 , 3);
 SegLCD_Set((Value & 0x000F)>>0 , 4);
}//End SegLCD_DisplayHex

void SegLCD_DisplayTime(uint8_t Value1, uint8_t Value2){//Displays 2 values separated by a colon
  SegLCD_Set(Value1/10, 1);
  SegLCD_Set(Value1 % 10, 2);
  SegLCD_Set(Value2/10, 3);
  SegLCD_Set(Value2 % 10, 4);
  SegLCD_Col_On();

}//End SegLCD_DisplayTime
/********************************LCD******************************/

//-------------------------------------------------------------------------------------------------------------------------------//

/********************************TSI******************************/
// TSI initialization function
void Touch_Init()
{
    // Enable clock for TSI PortB 16 and 17
    SIM->SCGC5 |= SIM_SCGC5_TSI_MASK;
     
     
    TSI0->GENCS = TSI_GENCS_OUTRGF_MASK |  // Out of range flag, set to 1 to clear
                                //TSI_GENCS_ESOR_MASK |  // This is disabled to give an interrupt when out of range.  Enable to give an interrupt when end of scan
                                TSI_GENCS_MODE(0u) |  // Set at 0 for capacitive sensing.  Other settings are 4 and 8 for threshold detection, and 12 for noise detection
                                TSI_GENCS_REFCHRG(0u) | // 0-7 for Reference charge
                                TSI_GENCS_DVOLT(0u) | // 0-3 sets the Voltage range
                                TSI_GENCS_EXTCHRG(0u) | //0-7 for External charge
                                TSI_GENCS_PS(0u) | // 0-7 for electrode prescaler
                                TSI_GENCS_NSCN(31u) | // 0-31 + 1 for number of scans per electrode
                                TSI_GENCS_TSIEN_MASK | // TSI enable bit
                                //TSI_GENCS_TSIIEN_MASK | //TSI interrupt is disables
                                TSI_GENCS_STPE_MASK | // Enables TSI in low power mode
                                //TSI_GENCS_STM_MASK | // 0 for software trigger, 1 for hardware trigger
                                //TSI_GENCS_SCNIP_MASK | // scan in progress flag
                                TSI_GENCS_EOSF_MASK ; // End of scan flag, set to 1 to clear
                                //TSI_GENCS_CURSW_MASK; // Do not swap current sources
                                 
}

// Function to read touch sensor from low to high capacitance for left to right
int Touch_Scan_LH(void)
{
    int scan;
    TSI0->DATA =     TSI_DATA_TSICH(10u); // Using channel 10 of The TSI
    TSI0->DATA |= TSI_DATA_SWTS_MASK; // Software trigger for scan
    scan = SCAN_DATA;
    TSI0->GENCS |= TSI_GENCS_EOSF_MASK ; // Reset end of scan flag
     
    return scan - SCAN_OFFSET;
}

// Function to read touch sensor from high to low capacitance for left to right
int Touch_Scan_HL(void)
{
    int scan;
    TSI0->DATA =     TSI_DATA_TSICH(9u); // Using channel 9 of the TSI
    TSI0->DATA |= TSI_DATA_SWTS_MASK; // Software trigger for scan
    scan = SCAN_DATA;
    TSI0->GENCS |= TSI_GENCS_EOSF_MASK ; // Reset end of scan flag
     
    return scan - SCAN_OFFSET;
}
/********************************TSI******************************/

//-------------------------------------------------------------------------------------------------------------------------------//

/**************************************************************/
/*																														*/
/*																														*/
/*										MINESWEEPER LOGIC												*/
/*																														*/
/*																														*/
/**************************************************************/

//-------------------------------------------------------------------------------------------//
//																	Replay																									 //
//-------------------------------------------------------------------------------------------//
/*
 * Function:  Replay
 * --------------------
 * asks for user if they want to play again
 *
 *  @params: none (void)
 *
 * 	@returns: if the user inputs 0 then the game ends, and
 *						restarts the game otherwise
 *
 *	Functions called : 	PutStringSB 
 *										 	NextLine 
 *											GetChar 
 *											PutChar 
 *											Restart
 */
void Replay(void){
	if(GameOver == true){
		PutStringSB("Time has run out, press the button to restart      ",MAXSTRING);}
		
	else{	
	PutStringSB("Do you want to play again?",MAXSTRING);
	NextLine();
	PutStringSB("Enter 1 for yes and 0 for No : ",MAXSTRING);
	char RP = GetChar() ;
	PlayAgain = RP - '0';
	PutChar(RP);
	//The player do not want to play again
	if(PlayAgain == 0){
		NextLine();
				GameOver = true;

		PutStringSB("Game Over    ",MAXSTRING);
	}
	else{
		restart();
	}			
}
}

//-------------------------------------------------------------------------------------------//
//																	difficulty																							 //
//-------------------------------------------------------------------------------------------//
/*
 * Function:  difficulty
 * -----------------------
 * 	prompts the user for difficulty level
 *	initialized with the following:
 *
 *	difficulty = 0
 *	score = 0
 *	max score = 0
 *
 *	updates each according to user input, turns ON Green LED
 *
 *  @params: none (void)
 *
 * 	@returns: initializes the difficulty level
 *	according to user input
 *
 *	Functions called : 	Green_LED_ON
 *										 	PutStringSB 
 *											NextLine
 *											GetChar 
 *											PutChar 
 *											easy
 *											intermediate
 *											hard
 *											expert
 */
void difficulty (void) {
	diff = 0;
	score = 0;
	MAX_SCORE = 0;
	Green_LED_ON();
	char diffchar = '0';
	while((diff != 1) && (diff != 2) && (diff != 3) && (diff != 4)) {
		PutStringSB("Select who you are: ", MAXSTRING);
		NextLine();
		PutStringSB("Peter Griffin - Easy (Enter '1') ", MAXSTRING);
		NextLine();
		PutStringSB("College Kid - Intermediate (Enter '2') ", MAXSTRING);
		NextLine();
		PutStringSB("CE Major - Hard (Enter '3') ", MAXSTRING);
		NextLine();
		PutStringSB("I coded the dame game! - Expert (Enter '4') ", MAXSTRING);
		NextLine();
		PutStringSB("Enter difficulty: ", MAXSTRING);
		diff = GetChar();
		diffchar = (char) diff;
		diff = diffchar - '0';
		PutChar(diffchar);
		NextLine();
		}
	
	
	if(diff == 1)	{
		NextLine();
		PutStringSB("Peter Griffin",MAXSTRING);
		easy();
	}
	
	else if(diff == 2)	{
		NextLine();
		PutStringSB("College Kid",MAXSTRING);
		intermediate();
	}
	else if(diff == 3)	{
		NextLine();
		PutStringSB("CE Major",MAXSTRING);
		hard();
	}
	else if(diff == 4)	{
		NextLine();
		PutStringSB("DEVELOPERS",MAXSTRING);
		expert();
	}
}

//-------------------------------------------------------------------------------------------//
//																			easy																								 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: easy
 * --------------------
 * initializes the game board in easy mode with the following
 * 
 *	rows	 : 5
 *	columns: 5
 *	mines	 : 5
 *
 *  @params: none (void)
 *
 * 	@returns: sets the rows, cols, total mines and maximum score
 *
 *	Functions called : 	NextLine 
 *										 	Init_Board
 *											input
 */
void easy(void) {
	NextLine();
	M = 5;
	N = 5;
	tot_mines = 5;
	Init_Board();
	score = 0;
	int MaxScorevalue = (10*M*N) - (10*tot_mines);
	MAX_SCORE = MaxScorevalue;
	//input();
}

//-------------------------------------------------------------------------------------------//
//																	intermediate																						 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: intermediate
 * --------------------
 * initializes the game board in intermediate mode with the following
 * 
 *	rows	 : 10
 *	columns: 10
 *	mines	 : 10
 *
 *  @params: none (void)
 *
 * 	@returns: sets the rows, cols, total mines and maximum score
 *
 *	Functions called : 	NextLine 
 *										 	Init_Board
 *											input
 */
void intermediate(void){
	M = 10;
	N = 10;
	tot_mines = 15;
	Init_Board();
	MAX_SCORE = (10*M*N) - (10*tot_mines);
	//input();
}

//-------------------------------------------------------------------------------------------//
//																		hard																									 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: hard
 * --------------------
 * initializes the game board in hard mode with the following
 * 
 *	rows	 : 15
 *	columns: 15
 *	mines	 : 30
 *
 *  @params: none (void)
 *
 * 	@returns: sets the rows, cols, total mines and maximum score
 *
 *	Functions called : 	NextLine 
 *										 	Init_Board
 *											input
 */
void hard(void){
	M = 15;
	N = 15;
	tot_mines = 30;
	
	Init_Board();
	MAX_SCORE = (10*M*N) - (10*tot_mines);
	//input();
}

//-------------------------------------------------------------------------------------------//
//																		expert																								 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: expert
 * --------------------
 * initializes the game board in expert mode with the following
 * 
 *	rows	 : 20
 *	columns: 20
 *	mines	 : 45
 *
 *  @params: none (void)
 *
 * 	@returns: sets the rows, cols, total mines and maximum score
 *
 *	Functions called : 	NextLine 
 *										 	Init_Board
 *											input
 */
void expert(void){
	M = 20;
	N = 20;
	tot_mines = 45;
	Init_Board();
	MAX_SCORE = (10*M*N) - (10*tot_mines);
	//input();
}

//-------------------------------------------------------------------------------------------//
//																	NotWithinBound																					 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: NotWithinBound
 * --------------------
 * takes in two ints and returns a boolean that checks whether those values
 * are within the boundary of the board
 *
 *  @params: i - row number
 *					 j - col number
 *					
 * 	@returns: boolean (false- out of board bounds, true- within board bounds)
 *
 *	Functions called : 	NONE
 */
bool NotWithinBound(int i, int j){
	if( i < 0 || i > M-1 || j < 0 || j > N-1){
		return true;}
	else{
		return false;
	}
}

//-------------------------------------------------------------------------------------------//
//																		Init_Board																						 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: Init_Board
 * --------------------
 * Initializes the game board with the preset of rows, cols and total mines.
 * Places mines in randomly generated coordinates where the seed for random generator
 * is retrieved using PIT timer and Count is passed as the seed for pseudo rng.
 * Updates the safe spots with number of nearby mines counted horizontally, vertically and
 * diagonally. 
 *
 *  @params: NONE (void)
 *					
 * 	@returns: a board initialized internally with the presets 
 *
 *	Functions called : 	srand
 *											Times_up
 *											rand
 *											NotWithinBound
 *											NextLine
 */
void Init_Board(void) {
	score = 0;
	match = 0;
	int i = 0;
	int j = 0;
	while (j < N) {
		while (i < M) {
			board[i][j] = 0;
			//Blank board represents if a space has been revealed
			blank_board[i][j] = 0;
			final_board[i][j] = board[i][j];
			i++;
		}
		i = 0;
		j++;
	}
	mines = 0;
	srand(Count);
	Times_up();
	while (mines < tot_mines) {
		i = rand() % (M);
		j = rand() % (N);
		//800000 is our integer value bombs 
		if(board[i][j] != 800000) {
			board[i][j] = 800000;
			final_board[i][j] = board[i][j];
			mines++;
		}
	}
	i = 0;
	j = 0;
	
	while (i<M){
		while(j<N){
			if(board[i][j] == 800000){
				//Top left
				if(board[i-1][j-1] != 800000 && !NotWithinBound(i-1,j-1)){
					board[i-1][j-1]++;}
				//Left
				if(board[i-1][j] != 800000 && !NotWithinBound(i-1,j)){
					board[i-1][j]++;}
				//Bottom left
				if(board[i-1][j+1] != 800000 && !NotWithinBound(i-1,j+1)){
					board[i-1][j+1]++;}
				//Bottom 
				if(board[i][j+1] != 800000 && !NotWithinBound(i,j+1)){
					board[i][j+1]++;}
				//Bottom Right
				if(board[i+1][j+1] != 800000 && !NotWithinBound(i+1,j+1)){
					board[i+1][j+1]++;}
				//Right
				if(board[i+1][j] != 800000 && !NotWithinBound(i+1,j)){
					board[i+1][j]++;}
				//Top Right
				if(board[i+1][j-1] != 800000 && !NotWithinBound(i+1,j-1)){
					board[i+1][j-1]++;}
				//Top
				if(board[i][j-1] != 800000 && !NotWithinBound(i,j-1)){
					board[i][j-1]++;}
				}
			j++;
			}
		i++;
		j=0;
		}
	i = 0;
	j = 0;
	NextLine();
	Count = 0;
}

//-------------------------------------------------------------------------------------------//
//																		Print_Board																						 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: Print_Board
 * --------------------
 * Echoes the initialized matrix(board) on the terminal screen with index where unrevealed spaces  
 * are represented by |-| and revealed spaces represented with the total number of adjacent mines.
 * Mines are represented by |B|. 
 *
 *  @params: NONE (void)
 *					
 * 	@returns: outputs the game board 
 *
 *	Functions called : 	NextLine
 *											PutStringSB	
 *											sprintf
 *											PutChar								
 */
void Print_Board(void) {
	int i = 0;
	int j = 0;
	int k = 0;
	NextLine();
	while(k < M) {
		if (k == 0) {
			PutStringSB("	",MAXSTRING);
		}
		PutStringSB("|",MAXSTRING);
		char str[12];
		sprintf(str, "%d", k);
		PutStringSB(str,MAXSTRING);
		PutStringSB("|",MAXSTRING);
		PutStringSB("	",MAXSTRING);
		k++;
	}
	NextLine();
	NextLine();
	while (j < N) {
		PutStringSB("|",MAXSTRING);
		char str[12];
		sprintf(str, "%d", j);
		PutStringSB(str,MAXSTRING);
		PutStringSB("|",MAXSTRING);
		PutStringSB("	",MAXSTRING);
		while (i < M) {
			//Check if the piece has been revelead
			if(blank_board[i][j] == 0){
					PutStringSB("|",MAXSTRING);
					PutChar('-');
					PutStringSB("|",MAXSTRING);
										PutStringSB("	",MAXSTRING);
			}
			else	{
				//Check for a bomb 
					if (board[i][j] == 800000) {
					PutStringSB("|",MAXSTRING);
					PutChar('B');
					PutStringSB("|",MAXSTRING);
					PutStringSB("	",MAXSTRING);
					}
				else {
					int b = board[i][j];
					char str[12];
					sprintf(str, "%d", b);
					PutStringSB("|",MAXSTRING);
					PutStringSB(str,MAXSTRING);
					PutStringSB("|",MAXSTRING);
					PutStringSB("	",MAXSTRING);
				}
			}
			i++;	
		}
		NextLine();
		i = 0;
		j++;
	}
}

//-------------------------------------------------------------------------------------------//
//																	Times_up																								 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: Times_up
 * --------------------
 * 	Updates the time limit according to the difficulty level selected.
 *	Toggles RED LED ON 		
 *
 *  @params: NONE (void)
 *					
 * 	@returns: sets HowMuchTime(time limit for each difficulty) 
 *
 *	Functions called : 	NONE
 *											
 */
void Times_up(){
	if(diff == 1){
		HowMuchTime = 90*100;
	}
	if(diff == 2){
		HowMuchTime = 180*100;}
	if(diff == 3){
		HowMuchTime = 360 *100;}
	if ( diff == 4){
		HowMuchTime = 720*100;}
}
		
//-------------------------------------------------------------------------------------------//
//																			input																								 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: input
 * --------------------
 * 	First checks whether the first turn of user sets off a mine and reinitializes board with same 
 *	difficulty of the session. Otherwise handles user input limited with HowMuchTime. If time limit
 *	is exceeded, game is over. Else, prompts for row and column number, handling the case where the 				
 *	input is out of the bounds of the board and whether its a previously entered coordinate. 	
 *	Recursive in nature. 		
 *	Flashes Green LED upon valid move		
 *					
 *  @params: NONE (void)
 *					
 * 	@returns: NONE (updates a coordinate on board with either a valid move or a mine)
 *
 *	Functions called : 	Print_Board
 *											game_over
 *											PutStringSB
 *											GetChar
 *											PutChar
 *											NotWithinBound
 *											GetChar
 *											nineEleven
 *											SegLCD_DisplayDecimal
 *											BlinkLED2
 */
void input(void) {
	
	
	
	int q = 0;
	int i = 0;
	int j = 0;
	int row = 0;
	int column = 0;
	int match = 0;
	
	Print_Board();
	char str[12];
	sprintf(str,"%d",Count);
	PutStringSB(str,MAXSTRING);
	NextLine();
	char adc[12];
	sprintf(adc,"%d",HowMuchTime);
	PutStringSB(adc,MAXSTRING);
	if(Count >= HowMuchTime){
		GameOver= true;
		game_over();
		}
	else{
	xval =0;
	yval = 0;
	if(diff == 1 || diff ==2){
			PutStringSB("Enter the row value: ", MAXSTRING);
			y = GetChar();
			yval = y - '0';
			PutChar(y);
			NextLine();
			PutStringSB("Enter the column value: ", MAXSTRING);
			x = GetChar();
			xval = x - '0';
			PutChar(x);
	}
	else{
			PutStringSB("Enter the row value: ", MAXSTRING);
			y = GetChar();
			PutChar(y);
			char y2 = GetChar();
			PutChar(y2);
			NextLine();
			PutStringSB("Enter the column value: ", MAXSTRING);
			x = GetChar();
			PutChar(x);
			char x2 = GetChar();
			PutChar(x2);
			int Y1 = (y - '0')*10;
			Y1 = (y2 - '0') + Y1;
			yval = Y1;
			int X1 = (x-'0')*10;
			X1 = (x2 - '0') +X1;
			xval = X1;
	}
	if (NotWithinBound(xval,yval)) {
			NextLine();
			PutStringSB("Please enter a value inside the board",MAXSTRING);
			NextLine();
			input();
	}
	if(board[xval][yval] == 800000) {
			nineEleven();
		
			//PutStringSB("DEBUG",MAXSTRING);
			game_over();
	}
	
	if(!GameOver){
			if(blank_board[xval][yval] != 0) {
				NextLine();
				PutStringSB("Please enter a value that has not been entered yet",MAXSTRING);
				NextLine();
				input();
		}	
		else {
			BlinkLED2();
			
			if(board[xval][yval] ==0){
				//PutStringSB("DAMN",MAXSTRING);
				Set0s(xval,yval);
				//PutStringSB("DAMN",MAXSTRING);
		}
			//PutStringSB("DAMN",MAXSTRING);
			blank_board[xval][yval] = 1;

			int currval = blank_board[xval][yval];
			NextLine();
			match += 1;
			score = match*10;
			SegLCD_DisplayDecimal(score);
			//Print_Board();
			if (match == ((M*N) - tot_mines)) {
			win();
			}
			else{
				input();}
			}
		}
	}
}
	

void Set0s(int x, int y){
	if(!NotWithinBound(x-1,y-1) && blank_board[x-1][y-1]!=1){
		match++;
		blank_board[x-1][y-1] = 1;
	}
	if(!NotWithinBound(x-1,y)&& blank_board[x-1][y]!=1){
				match++;

			blank_board[x-1][y] = 1;
	}
	if(!NotWithinBound(x-1,y+1)	&& blank_board[x-1][y+1]!=1){
				match++;

	blank_board[x-1][y+1] = 1;
	}
	if(!NotWithinBound(x+1,y-1) && blank_board[x+1][y-1]!=1){
				match++;

	blank_board[x+1][y-1] = 1;
	}
	if(!NotWithinBound(x+1,y+1) && blank_board[x+1][y+1]!=1){
				match++;

	blank_board[x+1][y+1] = 1;
	}
	if(!NotWithinBound(x+1,y) && blank_board[x+1][y]!=1){
				match++;

	blank_board[x+1][y] = 1;
	}
	if(!NotWithinBound(x,y-1) && blank_board[x][y-1]!=1){
				match++;

	blank_board[x][y-1] = 1;
	}
	if(!NotWithinBound(x,y+1) && blank_board[x][y+1]!=1){
				match++;

			blank_board[x][y+1] = 1;
	}	
}
	

//-------------------------------------------------------------------------------------------//
//																			nineEleven																					 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: nineEleven
 * --------------------
 *  First checks whether its the first move of user and reinitializes board with selected 	
 *  difficulty. Then handles the case where user hits a mine. It updates user with coordinates
 *  where they hit a mine then asking if they want to play again. 
 *					
 *  @params: NONE (void)
 *					
 * 	@returns: Prints the coordinates where the user hit a mine. Toggles Red LED ON.
 *
 *	Functions called : 	Print_Board
 *											PutStringSB
 *											GetChar
 *											PutChar
 *											NotWithinBound
 *											GetChar
 *											SegLCD_DisplayDecimal
 *											Red_LED_ON
 *											printscore
 *											sprintf
 */
void nineEleven(void) {
	
	
	Red_LED_ON();
	int row,col=0;
	row = 0;
	col =0;
	while (row < M){
		while ( col < N){
			blank_board[row][col] = 1;
			col ++;
		}
		col =0;
		row ++;
	}
	Print_Board();
	NextLine();
	PutStringSB("	",MAXSTRING);
	PutStringSB("You've hit a mine at ",MAXSTRING);
	char yString[12];
	char xString[12];
	sprintf(yString,"%d",yval);
	PutStringSB(yString, MAXSTRING);
	PutStringSB(",", MAXSTRING);
	sprintf(xString,"%d",xval);
	PutStringSB(xString, MAXSTRING);
	NextLine();
	printscore();
}
	

//-------------------------------------------------------------------------------------------//
//																			printscore																					 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: printscore
 * --------------------
 *  Displays the final score on the Segment LCD. Then outputs that to the terminal screen with 
 *  a tag based on the following scoring algorithm: 
 *		
 *  I'm just warming up 			- 	score in range  [0,1/4]  times MAX_SCORE
 *  Retake Assembly 					- 	score in range (1/4,1/2] times MAX_SCORE
 *  Eligible for DSD II 			-  	score in range (1/2,3/4] times MAX_SCORE
 *	I got petrol in my veins! - 	score in range  (3/4,1]  times MAX_SCORE
 *		
 *  @params: NONE (void)
 *					
 * 	@returns: Displays final score and player tag.
 *
 *	Functions called : 	SegLCD_DisplayDecimal
 *											PutStringSB
 *											sprintf
 *											NextLine
 */
void printscore(void) {
	SegLCD_DisplayDecimal(score);
	PutStringSB("Your Score: ", MAXSTRING);
	char ScoreString[12];
	sprintf(ScoreString, "%d", score);
	//char scorechar = score + '0';
	PutStringSB(ScoreString, MAXSTRING);
	NextLine();
	if (score <= (MAX_SCORE / 4)) {
		PutStringSB("I'm just warming up", MAXSTRING);
	}
	else if (score > (MAX_SCORE / 4) && score <= (MAX_SCORE / 2)) {
		PutStringSB("Retake Assembly", MAXSTRING);
	}
	else if (score > (MAX_SCORE / 2) && score <= (3 * MAX_SCORE / 4)) {
		PutStringSB("Eligible for DSD II", MAXSTRING);
	}
	else {
		PutStringSB("I got petrol in my veins!", MAXSTRING);
	}
}

//-------------------------------------------------------------------------------------------//
//																				win																								 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: win
 * --------------------
 *  Handles the case where the player wins the game.
 *		
 *  @params: NONE (void)
 *					
 * 	@returns: Displays final score on terminal, LCD display, toggles both LEDs ON and tags player
 *
 *	Functions called : 	SegLCD_DisplayDecimal
 *											PutStringSB
 *											sprintf
 *											NextLine
 */
void win(void) {
	//SegLCD_DisplayDecimal(MAX_SCORE);
	Green_LED_ON();
	Red_LED_ON();
	PutStringSB("Your Score: ", MAXSTRING);
	char ScoreString[12];
	sprintf(ScoreString, "%d", MAX_SCORE);
	PutStringSB(ScoreString, MAXSTRING);
	NextLine();
	PutStringSB("Winner Winner No Dinner", MAXSTRING);
	NextLine();
	Replay();
}

//-------------------------------------------------------------------------------------------//
//																			restart																					 		 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: restart
 * --------------------
 *  Restarts the game. If the first move was a mine, restarts game with same difficulty as before.  
 *		
 *  @params: NONE (void)
 *					
 * 	@returns: resets game and prompts for difficulty 
 *
 *	Functions called : 	NextLine
 *											PutStringSB
 *											difficulty
 */
void restart(void) {
	
	NextLine();
	PutStringSB("Restarting...", MAXSTRING);
	NextLine();
	difficulty();
}

//-------------------------------------------------------------------------------------------//
//																			rules																					 		 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: rules
 * --------------------
 *  Outputs instructions and rules for the game
 *		
 *  @params: NONE (void)
 *					
 * 	@returns: prints on terminal the rules
 *
 *	Functions called : 	PutStringSB
 *											NextLine
 */
void rules(void) {
	NextLine();
	PutStringSB("Rules of the game:", MAXSTRING);
	NextLine();
	PutStringSB("1. Each flagged space earns you 10 points.", MAXSTRING);
	NextLine();
	PutStringSB("2. You can't select previously selected coordinates.", MAXSTRING);
	NextLine();
	PutStringSB("3. There are 4 difficulty modes: Easy (5x5), Intermediate (10x10), Hard (15x15) and Expert (20x20).", MAXSTRING);
	NextLine();
	PutStringSB("4. Keep guessing, game over if you hit a mine.", MAXSTRING);
	NextLine();
	PutStringSB("5. Green LED for a successful flag placement, red for hitting a mine.", MAXSTRING);
	NextLine();
	PutStringSB("6. Easy Mode = 90 seconds, Intermediate = 180 seconds, Hard = 360 seconds, Expert = 720 seconds",MAXSTRING); 
}

//-------------------------------------------------------------------------------------------//
//																			game_over																				 		 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: game_over
 * --------------------
 *  Prints a round over prompt and prompts user if they want to play again. 
 *		
 *  @params: NONE (void)
 *					
 * 	@returns: NONE
 *
 *	Functions called : 	PutStringSB
 *											NextLine
 *											Replay
 */
void game_over(void) {
	NextLine();
	NextLine();
	PutStringSB("Round over!", MAXSTRING);
	NextLine();
	Replay();
}

//-------------------------------------------------------------------------------------------//
//																			NextLine																				 		 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: NextLine
 * --------------------
 *  Moves cursor to next line. Echoes a line feed and a carriage return to the terminal. 
 *		
 *  @params: NONE (void)
 *					
 * 	@returns: NONE
 *
 *	Functions called : 	PutChar
 */
void NextLine(void) {
	PutChar(0x0D);
	PutChar(0x0A);
}

//-------------------------------------------------------------------------------------------//
//																			main																						 		 //
//-------------------------------------------------------------------------------------------//
/*
 * Function: main
 * --------------------
 *  Drives the main code for the program. Masks interrupts, initializes hardware and peripherals.
 *  Starts a Timer to get a seed for random number generator. Initializes LCD with 0000 on display.
 *  Outputs the rules, prompts for difficulty and starts the game. 
 *		
 *  @params: NONE (void)
 *					
 * 	@returns: NONE
 */
int main (void) {
  __asm("CPSID   I");  /* mask interrupts */
  /* Perform all device initialization here */
  /* Before unmasking interrupts            */
  Init_UART0_IRQ ();
	Init_PIT_IRQ();
  Init_LED();
	SegLCD_Init();
	Touch_Init();
  __asm("CPSIE   I");  /* unmask interrupts */
	NextLine();
	TimeStart();
	PutStringSB("GHETTO MINESWEEPER CLONE ", MAXSTRING);
	SegLCD_DisplayDecimal(0000);
	NextLine();
	rules();
	difficulty();
  while ( GameOver != true){
		int row = 0;
		int column = 0;
		Print_Board();
		if(Count >= HowMuchTime){
			GameOver = true;
			game_over();
		}
		if(GameOver == false){
		xval =0;
		yval = 0;
		if(diff == 1 || diff ==2){
			PutStringSB("Enter the row value: ", MAXSTRING);
			y = GetChar();
			yval = y - '0';
			PutChar(y);
			NextLine();
			PutStringSB("Enter the column value: ", MAXSTRING);
			x = GetChar();
			xval = x - '0';
			PutChar(x);
	}
			else{
			PutStringSB("Enter the row value: ", MAXSTRING);
			y = GetChar();
			PutChar(y);
			char y2 = GetChar();
			PutChar(y2);
			NextLine();
			PutStringSB("Enter the column value: ", MAXSTRING);
			x = GetChar();
			PutChar(x);
			char x2 = GetChar();
			PutChar(x2);
			int Y1 = (y - '0')*10;
			Y1 = (y2 - '0') + Y1;
			yval = Y1;
			int X1 = (x-'0')*10;
			X1 = (x2 - '0') +X1;
			xval = X1;
	}
			if(board[xval][yval] == 800000) {
			nineEleven();
			game_over();
	}
			else if (NotWithinBound(xval,yval) && GameOver ==false) {
			NextLine();
			PutStringSB("Please enter a value inside the board",MAXSTRING);
			NextLine();
			//input();
	}
			
			else if (blank_board[xval][yval] != 0) {
				NextLine();
				PutStringSB("Please enter a value that has not been entered yet",MAXSTRING);
				NextLine();
				//input();
		}	
			else {
			BlinkLED2();
			
			if(board[xval][yval] ==0){
				Set0s(xval,yval);
		}
			blank_board[xval][yval] = 1;

			int currval = blank_board[xval][yval];
			NextLine();
			match += 1;
			score = match*10;
			SegLCD_DisplayDecimal(score);
			//Print_Board();
			if (match == ((M*N) - tot_mines)) {
			win();
			}
		}
	}
}
	
				
			
		
		
} /* main */

//-------------------------------------------------------------------------------------------//
//																				EOF																							 	 //
//-------------------------------------------------------------------------------------------//
